{
    "0": "class Hexagons(object):\n\n    def __init__(self, dir, unit_dist):\n        files = os.listdir(dir)\n        self.contour_list = []\n        self.unit_dist = unit_dist\n        self.evens = OrderedDict()\n        self.odds = OrderedDict()\n        for file in files:\n            path = dir + '/' + file\n            self.contour_list.append(Contour(path, unit_dist))\n\n    def add_points(self, points, even_flag):\n        if even_flag:\n            for p in points:\n                self.evens[p] = None\n            for i in range(len(points) - 1):\n                self.odds[(points[i] + points[i + 1]) / 2] = None\n        else:\n            for p in points:\n                self.odds[p] = None\n            for i in range(len(points) - 1):\n                self.evens[(points[i] + points[i + 1]) / 2] = None\n\n    def get_offset(self, key, point):\n        return (key % self.unit_dist - point % self.unit_dist) % self.unit_dist\n\n    def format_key_points(self):\n        for i in range(len(self.contour_list)):\n            contour = self.contour_list[i]\n            start = contour.start\n            keys = []\n            coords = []\n            even_flag = True\n            if i == 0:\n                coords = contour.set_key_points()\n                self.add_points(coords, even_flag)\n            elif i % 2 == 0:\n                keys = list(self.evens.keys())\n                if start in self.evens:\n                    coords = contour.set_key_points()\n            else:\n                even_flag = False\n                keys = list(self.odds.keys())\n                if start in self.odds:\n                    coords = contour.set_key_points()\n            if not coords:\n                if start > keys[-1]:\n                    offset = self.get_offset(keys[-1], start)\n                elif start < keys[0]:\n                    offset = self.get_offset(keys[0], start)\n                else:\n                    counter = 0\n                    while keys[counter] < start:\n                        counter += 1\n                    offset = self.get_offset(keys[counter - 1], start)\n                coords = contour.set_key_points(inner_start=offset + start)\n            self.add_points(coords[1:], even_flag)\n\n    def get_measurements(self):\n        side_length = self.unit_dist / sqrt(3)\n        offset = sqrt(pow(side_length, 2) - pow(self.unit_dist / 2, 2))\n        return (side_length, offset)\n\n    def create_mesh(self, view):\n        x = []\n        y = []\n        z = []\n        triangles = []\n        all_rectangles = []\n        count = 0\n        side_length, offset = self.get_measurements()\n        base = 0\n        for contour in self.contour_list:\n            hexagons, rectangle = contour.get_polygons(base)\n            all_rectangles.extend(rectangle)\n            for p in hexagons:\n                count += 1\n                for l in p:\n                    x.append(l[0])\n                    y.append(l[1])\n                    z.append(l[2])\n                p = np.array(p)\n            base = base + side_length + offset\n        for i in range(0, count):\n            triangles.append(np.array([0, 1, 2]) + i * 12)\n            triangles.append(np.array([1, 2, 3]) + i * 12)\n            triangles.append(np.array([2, 3, 4]) + i * 12)\n            triangles.append(np.array([3, 4, 5]) + i * 12)\n            triangles.append(np.array([4, 5, 6]) + i * 12)\n            triangles.append(np.array([5, 6, 7]) + i * 12)\n            triangles.append(np.array([6, 7, 8]) + i * 12)\n            triangles.append(np.array([7, 8, 9]) + i * 12)\n            triangles.append(np.array([8, 9, 10]) + i * 12)\n            triangles.append(np.array([9, 10, 11]) + i * 12)\n            triangles.append(np.array([10, 11, 0]) + i * 12)\n            triangles.append(np.array([11, 0, 1]) + i * 12)\n        triangular_mesh(x, y, z, triangles)\n        savefig(view + '/figure.obj')\n        show()",
    "1": "def add_points(self, points, even_flag):\n    if even_flag:\n        for p in points:\n            self.evens[p] = None\n        for i in range(len(points) - 1):\n            self.odds[(points[i] + points[i + 1]) / 2] = None\n    else:\n        for p in points:\n            self.odds[p] = None\n        for i in range(len(points) - 1):\n            self.evens[(points[i] + points[i + 1]) / 2] = None",
    "2": "def format_key_points(self):\n    for i in range(len(self.contour_list)):\n        contour = self.contour_list[i]\n        start = contour.start\n        keys = []\n        coords = []\n        even_flag = True\n        if i == 0:\n            coords = contour.set_key_points()\n            self.add_points(coords, even_flag)\n        elif i % 2 == 0:\n            keys = list(self.evens.keys())\n            if start in self.evens:\n                coords = contour.set_key_points()\n        else:\n            even_flag = False\n            keys = list(self.odds.keys())\n            if start in self.odds:\n                coords = contour.set_key_points()\n        if not coords:\n            if start > keys[-1]:\n                offset = self.get_offset(keys[-1], start)\n            elif start < keys[0]:\n                offset = self.get_offset(keys[0], start)\n            else:\n                counter = 0\n                while keys[counter] < start:\n                    counter += 1\n                offset = self.get_offset(keys[counter - 1], start)\n            coords = contour.set_key_points(inner_start=offset + start)\n        self.add_points(coords[1:], even_flag)",
    "3": "def create_mesh(self, view):\n    x = []\n    y = []\n    z = []\n    triangles = []\n    all_rectangles = []\n    count = 0\n    side_length, offset = self.get_measurements()\n    base = 0\n    for contour in self.contour_list:\n        hexagons, rectangle = contour.get_polygons(base)\n        all_rectangles.extend(rectangle)\n        for p in hexagons:\n            count += 1\n            for l in p:\n                x.append(l[0])\n                y.append(l[1])\n                z.append(l[2])\n            p = np.array(p)\n        base = base + side_length + offset\n    for i in range(0, count):\n        triangles.append(np.array([0, 1, 2]) + i * 12)\n        triangles.append(np.array([1, 2, 3]) + i * 12)\n        triangles.append(np.array([2, 3, 4]) + i * 12)\n        triangles.append(np.array([3, 4, 5]) + i * 12)\n        triangles.append(np.array([4, 5, 6]) + i * 12)\n        triangles.append(np.array([5, 6, 7]) + i * 12)\n        triangles.append(np.array([6, 7, 8]) + i * 12)\n        triangles.append(np.array([7, 8, 9]) + i * 12)\n        triangles.append(np.array([8, 9, 10]) + i * 12)\n        triangles.append(np.array([9, 10, 11]) + i * 12)\n        triangles.append(np.array([10, 11, 0]) + i * 12)\n        triangles.append(np.array([11, 0, 1]) + i * 12)\n    triangular_mesh(x, y, z, triangles)\n    savefig(view + '/figure.obj')\n    show()",
    "4": "def start_callback(view):\n    \"\"\"Callback function for the start button. Asks user to use default or custom parameters.\"\"\"\n    mb.showinfo(title='Select Base Image', message=dpnd.file_msg)\n    file_select = tk.Button(text='Click to Open Base Image File', command=lambda: parameter_callback(view)).pack(fill=tk.X)",
    "5": "def parameter_callback(view):\n    \"\"\"Callback function that guides user with selecting parameter values.\"\"\"\n    global thresh_vals, range_vals, poi, win\n    win.update()\n    base_dir = 'C:/Users/prath/Desktop/ResearchProject/ResearchProject/python_scripts/' + view + '/TestImages'\n    file_path = fd.askopenfilename(initialdir=base_dir)\n    img = cv2.imread(file_path)\n    mb.showinfo(title='Isolate Spinal Cord', message=dpnd.isolate_sc_msg)\n    crop_points(view + '/TestImages', view + '/Isolated', img)\n    isolated_dir = 'C:/Users/prath/Desktop/ResearchProject/ResearchProject/python_scripts/' + view + '/Isolated'\n    mb.showinfo(title='Select Processed Image and Image Range', message=dpnd.roi_file_msg)\n    file_path = fd.askopenfilename(initialdir=isolated_dir)\n    img = cv2.imread(file_path)\n    mb.showinfo(title='Isolate Region of Interest', message=dpnd.isolate_roi_msg)\n    crop_points(view + '/Isolated', view + '/PreProImages', img)\n    range_vals.append(int(input('Please enter the number of the starting image: ')))\n    range_vals.append(int(input('Please enter the number of the ending image: ')))\n    processed_dir = 'C:/Users/prath/Desktop/ResearchProject/ResearchProject/python_scripts/' + view + '/PreProImages'\n    compute.process_images(processed_dir)\n    threshold_callback(view)\n    mb.showinfo(title='Select Point of Interest', message=dpnd.poi_msg)\n    file_path = fd.askopenfilename(initialdir=processed_dir.replace('PreProImages', 'Thresholded'))\n    img = cv2.imread(file_path)\n    poi = get_poi(img)\n    mb.showinfo(title='Reading The Output', message=dpnd.completion_msg)\n    done = tk.Button(text='Start contour creation!', command=quit_callback).pack(fill=tk.X)",
    "6": "def threshold_callback(view):\n    \"\"\"Helps user identify threshold range and crop resulting image\"\"\"\n    global thresh_vals, range_vals, poi, win\n    mb.showinfo(title='Identify Threshold Values', message=dpnd.threshold_msg)\n    processed_dir = 'C:/Users/prath/Desktop/ResearchProject/ResearchProject/python_scripts/' + view + '/PreProImages'\n    file_path = fd.askopenfilename(initialdir=processed_dir)\n    img = cv2.imread(file_path)\n    get_threshold_vals(img)\n    thresh_vals.append(int(input('Please enter the value for the lower threshold: ')))\n    thresh_vals.append(int(input('Please enter the value for the upper threshold: ')))\n    compute.threshold(view, range_vals, thresh_vals[0], thresh_vals[1])\n    threshold_dir = processed_dir.replace('PreProImages', 'Thresholded')\n    mb.showinfo(title='Select Thresholded Image', message=dpnd.select_thresh_msg)\n    file_path = fd.askopenfilename(initialdir=threshold_dir)\n    img = cv2.imread(file_path)\n    mb.showinfo(title='Isolate Thresholded Region', message=dpnd.isolate_roi_msg)\n    points = crop_points(view + '/Thresholded', view + '/Thresholded', img)",
    "7": "def draw_line_callback(event, x, y, flags, param):\n    \"\"\"Callback function to help user draw lines on image.\"\"\"\n    img = param[0]\n    points = param[1]\n    if event == cv2.EVENT_LBUTTONDBLCLK:\n        cv2.circle(img, (x, y), 5, (255, 0, 0), -1)\n        points.append((x, y))\n        i = len(points) - 1\n        if i > 0:\n            cv2.line(img, points[i - 1], points[i], (255, 0, 0), 1)",
    "8": "def get_threshold_vals(img):\n    \"\"\"Creates OpenCV window with selected image. Uses corresponding callback function to show values to user.\"\"\"\n    cv2.namedWindow('image')\n    param = [img]\n    cv2.setMouseCallback('image', threshold_vals_callback, param)\n    while 1:\n        cv2.imshow('image', img)\n        if cv2.waitKey(20) & 255 == 27:\n            break\n    cv2.destroyAllWindows()",
    "9": "def get_poi(img):\n    \"\"\"Creates OpenCV window with selected image. Uses corresponding callback function to show values to user.\"\"\"\n    cv2.namedWindow('image')\n    point = []\n    param = [img, point]\n    cv2.setMouseCallback('image', poi_callback, param)\n    while 1:\n        cv2.imshow('image', img)\n        if cv2.waitKey(20) & 255 == 27:\n            break\n    cv2.destroyAllWindows()\n    return point",
    "10": "def poi_callback(event, x, y, flags, param):\n    \"\"\"Gets values for parameters through listening for mouse clicks on image window\"\"\"\n    img = param[0]\n    point = param[1]\n    if event == cv2.EVENT_LBUTTONDBLCLK:\n        cv2.circle(img, (x, y), 4, (255, 0, 0), -1)\n        point.append(x)\n        point.append(y)",
    "11": "def main():\n    \"\"\"main function\"\"\"\n    global thresh_vals, range_vals, poi, win\n    view = input('Please enter the MRI perspective (coronal, sagittal, or axial): \\n')\n    directions = tk.Message(text=dpnd.intro_msg)\n    directions.pack()\n    start_button = tk.Button(win, text='Start!', command=lambda: start_callback(view))\n    start_button.pack()\n    win.geometry('700x350')\n    win.mainloop()\n    win.quit()\n    contours = []\n    if thresh_vals:\n        contours = compute.draw_contours(view, range_vals, poi)\n    else:\n        print('error')\n    compute.create_mesh(view)",
    "12": "\nimport os\n \ndirs = ['/Convex', '/Isolated', '/PreProImages', '/Regular', '/OverlayedConvexImages',  '/OverlayedImages', '/Thresholded']\n\nviews = ['coronal', 'sagittal']\nfor view in views:\n    for dir in dirs:\n        dir = view + dir\n        for f in os.listdir(dir):\n            os.remove(os.path.join(dir, f))",
    "13": "def start_callback(view):\n    \"\"\"Callback function for the start button. Asks user to use default or custom parameters.\"\"\"\n    mb.showinfo(title='Select Base Image', message=dpnd.file_msg)\n    file_select = ctk.CTkButton(master=win, text='Open File', command=lambda: parameter_callback(view)).pack(pady=50)",
    "14": "def parameter_callback(view):\n    \"\"\"Callback function that guides user with selecting parameter values.\"\"\"\n    global bounds, range_vals, poi, win\n    win.update()\n    base_dir = BASE_PATH + view + '/TestImages'\n    file_path = fd.askopenfilename(initialdir=base_dir)\n    img = cv2.imread(file_path)\n    mb.showinfo(title='Isolate Spinal Cord', message=dpnd.isolate_sc_msg)\n    crop_points(view + '/TestImages', view + '/Isolated', img)\n    isolated_dir = BASE_PATH + view + '/Isolated'\n    mb.showinfo(title='Select Processed Image and Image Range', message=dpnd.roi_file_msg)\n    file_path = fd.askopenfilename(initialdir=isolated_dir)\n    img = cv2.imread(file_path)\n    mb.showinfo(title='Isolate Region of Interest', message=dpnd.isolate_roi_msg)\n    crop_points(view + '/Isolated', view + '/PreProImages', img)\n    dialog = ctk.CTkInputDialog(text='Please enter the number of the starting image:', title='Starting Number')\n    start = dialog.get_input()\n    dialog = ctk.CTkInputDialog(text='Please enter the number of the ending image:', title='Ending Number')\n    end = dialog.get_input()\n    range_vals.append(int(start))\n    range_vals.append(int(end))\n    processed_dir = BASE_PATH + view + '/PreProImages'\n    compute.process_images(processed_dir)\n    bounding(view)\n    mb.showinfo(title='Select Point of Interest', message=dpnd.poi_msg)\n    file_path = fd.askopenfilename(initialdir=processed_dir.replace('PreProImages', 'Thresholded'))\n    img = cv2.imread(file_path)\n    poi = get_poi(img)\n    mb.showinfo(title='Reading The Output', message=dpnd.completion_msg)\n    done = ctk.CTkButton(master=win, text='Start contour creation!', command=quit_callback).pack(pady=20)",
    "15": "def bounding(view):\n    \"\"\"Helps user identify bounds range and crop resulting image\"\"\"\n    global bounds, range_vals, poi, win\n    mb.showinfo(title='Identify Bound Values', message=dpnd.bounding_msg)\n    processed_dir = BASE_PATH + view + '/PreProImages'\n    file_path = fd.askopenfilename(initialdir=processed_dir)\n    img = cv2.imread(file_path)\n    get_bounds(img)\n    dialog = ctk.CTkInputDialog(text='Please enter the value for the lower bound:', title='Lower Bound')\n    lower = dialog.get_input()\n    dialog = ctk.CTkInputDialog(text='Please enter the value for the upper bound:', title='Upper Bound')\n    upper = dialog.get_input()\n    bounds.append(int(lower))\n    bounds.append(int(upper))\n    compute.threshold(view, range_vals, bounds[0], bounds[1])\n    threshold_dir = processed_dir.replace('PreProImages', 'Thresholded')\n    mb.showinfo(title='Select Thresholded Image', message=dpnd.select_thresh_msg)\n    file_path = fd.askopenfilename(initialdir=threshold_dir)\n    img = cv2.imread(file_path)\n    mb.showinfo(title='Isolate Thresholded Region', message=dpnd.isolate_roi_msg)\n    points = crop_points(view + '/Thresholded', view + '/Thresholded', img)",
    "16": "def get_bounds(img):\n    \"\"\"Creates OpenCV window with selected image. Uses corresponding callback function to show values to user.\"\"\"\n    cv2.namedWindow('image')\n    param = [img]\n    cv2.setMouseCallback('image', bound_vals_callback, param)\n    while 1:\n        cv2.imshow('image', img)\n        if cv2.waitKey(20) & 255 == 27:\n            break\n    cv2.destroyAllWindows()",
    "17": "def quit_callback():\n    \"\"\"Callback function to close the main window.\"\"\"\n    global win\n    win.quit()",
    "18": "def draw_line_callback(event, x, y, flags, param):\n    \"\"\"Callback function to help user draw lines on image.\"\"\"\n    img = param[0]\n    points = param[1]\n    if event == cv2.EVENT_LBUTTONDBLCLK:\n        cv2.circle(img, (x, y), 5, (255, 0, 0), -1)\n        points.append((x, y))\n        i = len(points) - 1\n        if i > 0:\n            cv2.line(img, points[i - 1], points[i], (255, 0, 0), 1)",
    "19": "def get_poi(img):\n    \"\"\"Creates OpenCV window with selected image. Uses corresponding callback function to show values to user.\"\"\"\n    cv2.namedWindow('image')\n    point = []\n    param = [img, point]\n    cv2.setMouseCallback('image', poi_callback, param)\n    while 1:\n        cv2.imshow('image', img)\n        if cv2.waitKey(20) & 255 == 27:\n            break\n    cv2.destroyAllWindows()\n    return point",
    "20": "def poi_callback(event, x, y, flags, param):\n    \"\"\"Gets values for parameters through listening for mouse clicks on image window\"\"\"\n    img = param[0]\n    point = param[1]\n    if event == cv2.EVENT_LBUTTONDBLCLK:\n        cv2.circle(img, (x, y), 4, (255, 0, 0), -1)\n        point.append(x)\n        point.append(y)",
    "21": "def main():\n    \"\"\"main function\"\"\"\n    global bounds, range_vals, poi, win, temp_view\n    view_window = ctk.CTkToplevel()\n    view_window.geometry('300x250')\n    view_directions = ctk.CTkLabel(master=view_window, text='Please enter the MRI perspective.\\n After your selection, close the window to continue.\\n')\n    view_directions.pack()\n    view_box = ctk.CTkOptionMenu(master=view_window, values=['coronal', 'sagittal', 'axial'], command=menu_callback)\n    view_box.set('')\n    view_box.pack()\n    directions = ctk.CTkLabel(master=win, text=dpnd.intro_msg)\n    directions.pack()\n    start_button = ctk.CTkButton(master=win, text='Start!', command=lambda: start_callback(temp_view))\n    start_button.pack()\n    win.geometry('600x350')\n    win.mainloop()\n    win.quit()\n    if bounds:\n        compute.draw_contours(temp_view, range_vals, poi)\n    else:\n        print('error')\n    compute.create_mesh(temp_view)",
    "22": "import numpy as np\nimport cv2\nimport os\nimport math\ndef enlarge(view):\n    dir = view + '/TestImages'\n    files = os.listdir(dir)\n\n    for file_name in files:\n        print(dir + '/' + file_name)\n        img = cv2.imread(view + '/TestImages/' + file_name, cv2.IMREAD_UNCHANGED)\n\n        print('Original Dimensions : ',img.shape)\n\n        scale_percent = 300 # percent of original size\n        width = int(img.shape[1] * scale_percent / 100)\n        height = int(img.shape[0] * scale_percent / 100)\n        dim = (width, height)\n\n        # resize image\n        resized = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)\n        cv2.imwrite(view + '/TestImages/' + file_name, resized)\n\ndef contours(img, low, high):\n    red_image = np.zeros((img.shape[0], img.shape[1], 3), np.uint8)\n    red_image[:] = (0, 0, 255)\n    lower_gray = np.array([low])\n    upper_gray = np.array([high])\n    lesion_mask = cv2.inRange(img, lower_gray, upper_gray)\n    hull_res = cv2.bitwise_and(red_image, red_image, mask=lesion_mask)\n    rect_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 30))\n    gray = cv2.cvtColor(hull_res, cv2.COLOR_BGR2GRAY)\n    threshed = cv2.morphologyEx(gray, cv2.MORPH_CLOSE, rect_kernel)\n    hull_contours, hierarchy = cv2.findContours(threshed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n\n    cv2.drawContours(hull_res, hull_contours, -1, (0, 255, 0), 1)\n\n\n    return hull_res \n\ndef get_threshold_vals(img):\n    \"\"\"Creates OpenCV window with selected image. Uses corresponding callback function to show values to user.\"\"\"\n    cv2.namedWindow('image')\n    param = [img]\n    cv2.setMouseCallback('image', threshold_vals_callback, param)\n    while 1:\n        cv2.imshow('image', img)\n        if cv2.waitKey(20) & 0xFF == 27:\n            break\n    cv2.destroyAllWindows()\n\n\ndef threshold_vals_callback(event, x, y, flags, param):\n    \"\"\"Gets values for parameters through listening for mouse clicks on image window\"\"\"\n    img = param[0]\n\n    # checks event for single click of right mouse button, printing the grayscale value at the point of the click\n    if event == cv2.EVENT_LBUTTONDBLCLK:\n        val = img[y, x]\n        print(\"Value: \", val)\n        print(y,x)\n\ndef distance(p1, p2):\n    return math.sqrt(((p1[0] - p2[0]) ** 2) + ((p1[1] - p2[1]) ** 2))\n\ndef central_contour(contours, img_center):\n    index = 0\n    curr_min = 10000000\n    for i in range(len(contours)):\n        M = cv2.moments(contours[i])\n        if M['m00'] != 0:\n            x = int(M['m10'] / M['m00'])\n            y = int(M['m01'] / M['m00'])\n            center = (x, y)\n            dist = distance(center, img_center)\n            if dist < curr_min:\n                index = i\n                curr_min = dist\n\n    return contours[index]\ndef draw_contours(poi):\n    \"\"\"Function that draws contour lines on images based on given parameters\"\"\"\n\n    print(\"\\nStarting contour drawings!\")\n    hull_list = []\n \n    # Create range to see which images will be processed\n    count = 0\n\n    # For loop to go through directory of processed images and apply contour drawing algorithm\n    files = os.listdir('./Thresholded')\n\n    for file_name in files:\n        file_path = './Thresholded/' + file_name\n        res = cv2.imread(file_path)\n        gray = cv2.cvtColor(res, cv2.COLOR_BGR2GRAY)\n\n        # Defines center\n        img_center = (poi[0], poi[1])\n\n        # Finds and draws the contours on red background\n        edged = cv2.Canny(gray, 100, 200)\n        contours, hierarchy = cv2.findContours(edged, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n        center_contour = [central_contour(contours, img_center)]\n        cv2.drawContours(res, center_contour, -1, (0, 255, 0), 1)\n\n        # Creates convex image\n\n        # Draws contours on isolated spinal cord with MRI background\n\n        # Draws Hull Convexes on both red bg image and MRI background\n        hull_res = cv2.imread(file_path)\n        rect_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 30))\n        threshed = cv2.morphologyEx(gray, cv2.MORPH_CLOSE, rect_kernel)\n        hull_contours, hierarchy = cv2.findContours(threshed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n\n        hull_center_contour = cv2.convexHull(central_contour(hull_contours, img_center))\n        hull_list.append(hull_center_contour)\n        hull_center_contour = [hull_center_contour]\n\n        thickness = 1\n\n        # if count == 0 or count == len(files) - 1:\n        #     thickness = -1\n\n        cv2.drawContours(hull_res, hull_center_contour, -1, (0, 255, 0), thickness)\n        \n        # Write images into respective directories\n        \n        count += 1\n\n    # Contour drawing is finished, ask user to retrace any contours\n    print('\\nFinished contour drawings!\\n')\n    cv2.imwrite(\"new.png\", hull_res[11])\n    return hull_list[11]\n\nif __name__ == '__main__':\n    print(draw_contours((96,141)))",
    "23": "def enlarge(view):\n    dir = view + '/TestImages'\n    files = os.listdir(dir)\n    for file_name in files:\n        print(dir + '/' + file_name)\n        img = cv2.imread(view + '/TestImages/' + file_name, cv2.IMREAD_UNCHANGED)\n        print('Original Dimensions : ', img.shape)\n        scale_percent = 300\n        width = int(img.shape[1] * scale_percent / 100)\n        height = int(img.shape[0] * scale_percent / 100)\n        dim = (width, height)\n        resized = cv2.resize(img, dim, interpolation=cv2.INTER_AREA)\n        cv2.imwrite(view + '/TestImages/' + file_name, resized)",
    "24": "def contours(img, low, high):\n    red_image = np.zeros((img.shape[0], img.shape[1], 3), np.uint8)\n    red_image[:] = (0, 0, 255)\n    lower_gray = np.array([low])\n    upper_gray = np.array([high])\n    lesion_mask = cv2.inRange(img, lower_gray, upper_gray)\n    hull_res = cv2.bitwise_and(red_image, red_image, mask=lesion_mask)\n    rect_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 30))\n    gray = cv2.cvtColor(hull_res, cv2.COLOR_BGR2GRAY)\n    threshed = cv2.morphologyEx(gray, cv2.MORPH_CLOSE, rect_kernel)\n    hull_contours, hierarchy = cv2.findContours(threshed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n    cv2.drawContours(hull_res, hull_contours, -1, (0, 255, 0), 1)\n    return hull_res",
    "25": "def get_threshold_vals(img):\n    \"\"\"Creates OpenCV window with selected image. Uses corresponding callback function to show values to user.\"\"\"\n    cv2.namedWindow('image')\n    param = [img]\n    cv2.setMouseCallback('image', threshold_vals_callback, param)\n    while 1:\n        cv2.imshow('image', img)\n        if cv2.waitKey(20) & 255 == 27:\n            break\n    cv2.destroyAllWindows()",
    "26": "def distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
    "27": "def central_contour(contours, img_center):\n    index = 0\n    curr_min = 10000000\n    for i in range(len(contours)):\n        M = cv2.moments(contours[i])\n        if M['m00'] != 0:\n            x = int(M['m10'] / M['m00'])\n            y = int(M['m01'] / M['m00'])\n            center = (x, y)\n            dist = distance(center, img_center)\n            if dist < curr_min:\n                index = i\n                curr_min = dist\n    return contours[index]",
    "28": "def draw_contours(poi):\n    \"\"\"Function that draws contour lines on images based on given parameters\"\"\"\n    print('\\nStarting contour drawings!')\n    hull_list = []\n    count = 0\n    files = os.listdir('./Thresholded')\n    for file_name in files:\n        file_path = './Thresholded/' + file_name\n        res = cv2.imread(file_path)\n        gray = cv2.cvtColor(res, cv2.COLOR_BGR2GRAY)\n        img_center = (poi[0], poi[1])\n        edged = cv2.Canny(gray, 100, 200)\n        contours, hierarchy = cv2.findContours(edged, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n        center_contour = [central_contour(contours, img_center)]\n        cv2.drawContours(res, center_contour, -1, (0, 255, 0), 1)\n        hull_res = cv2.imread(file_path)\n        rect_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 30))\n        threshed = cv2.morphologyEx(gray, cv2.MORPH_CLOSE, rect_kernel)\n        hull_contours, hierarchy = cv2.findContours(threshed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n        hull_center_contour = cv2.convexHull(central_contour(hull_contours, img_center))\n        hull_list.append(hull_center_contour)\n        hull_center_contour = [hull_center_contour]\n        thickness = 1\n        cv2.drawContours(hull_res, hull_center_contour, -1, (0, 255, 0), thickness)\n        count += 1\n    print('\\nFinished contour drawings!\\n')\n    cv2.imwrite('new.png', hull_res[11])\n    return hull_list[11]",
    "29": "import numpy as np\nimport cv2\nimport os\n\ndef main(view):\n    dir = view + '/TestImages'\n    files = os.listdir(dir)\n\n    for file_name in files:\n        print(dir + '/' + file_name)\n        img = cv2.imread(view + '/TestImages/' + file_name, cv2.IMREAD_UNCHANGED)\n\n        print('Original Dimensions : ',img.shape)\n\n        scale_percent = 300 # percent of original size\n        width = int(img.shape[1] * scale_percent / 100)\n        height = int(img.shape[0] * scale_percent / 100)\n        dim = (width, height)\n\n        # resize image\n        resized = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)\n        cv2.imwrite(view + '/TestImages/' + file_name, resized)\n\n    \n\nif __name__ == '__main__':\n    view = input(\"enter view\\n\")\n    main(view)\n\n\n\n ",
    "30": "def main(view):\n    dir = view + '/TestImages'\n    files = os.listdir(dir)\n    for file_name in files:\n        print(dir + '/' + file_name)\n        img = cv2.imread(view + '/TestImages/' + file_name, cv2.IMREAD_UNCHANGED)\n        print('Original Dimensions : ', img.shape)\n        scale_percent = 300\n        width = int(img.shape[1] * scale_percent / 100)\n        height = int(img.shape[0] * scale_percent / 100)\n        dim = (width, height)\n        resized = cv2.resize(img, dim, interpolation=cv2.INTER_AREA)\n        cv2.imwrite(view + '/TestImages/' + file_name, resized)",
    "31": "class Contour(object):\n\n    def __init__(self, path, unit_dist):\n        img = cv2.imread(path)\n        green = [0, 255, 0]\n        y, x = np.where(np.all(img == green, axis=2))\n        points = []\n        for p1, p2 in zip(x, y):\n            points.append([p1, p2])\n        self.point_list = sorted(points, key=lambda x: int(x[0]))\n        self.start = self.point_list[0][0]\n        self.end = self.point_list[-1][0]\n        self.unit_dist = unit_dist\n        self.key_points = {}\n        self.x_coords = []\n\n    def set_key_points(self, inner_start=0):\n        num_rect = floor((self.end - self.start) / self.unit_dist) - 1\n        self.key_points[self.start] = []\n        x_coords = [self.start]\n        if not inner_start:\n            for i in range(0, num_rect + 1):\n                x_coords.append(x_coords[-1] + self.unit_dist)\n                self.key_points[x_coords[-1]] = []\n        else:\n            self.key_points[inner_start] = []\n            x_coords.append(inner_start)\n            for i in range(0, num_rect):\n                x_coords.append(x_coords[-1] + self.unit_dist)\n                self.key_points[x_coords[-1]] = []\n        for i in range(1, len(x_coords) - 1):\n            self.key_points[(x_coords[i] + x_coords[i + 1]) / 2] = []\n        for p in self.point_list:\n            if p[0] in self.key_points:\n                self.key_points[p[0]].append(p[1])\n        for p in self.key_points:\n            self.key_points[p] = [self.key_points[p][0], self.key_points[p][-1]]\n        self.x_coords = x_coords\n        return x_coords\n\n    def get_measurements(self):\n        side_length = self.unit_dist / sqrt(3)\n        offset = sqrt(pow(side_length, 2) - pow(self.unit_dist / 2, 2))\n        return (side_length, offset)\n\n    def get_polygons(self, base):\n        x_coords = self.x_coords\n        hexagons = []\n        side_length, offset = self.get_measurements()\n        for i in range(1, len(x_coords) - 1):\n            curr = x_coords[i]\n            next = x_coords[i + 1]\n            hexagons.append([[curr, self.key_points[curr][0], base + offset], [curr, self.key_points[curr][1], base + offset], [(curr + next) / 2, self.key_points[(curr + next) / 2][0], base], [(curr + next) / 2, self.key_points[(curr + next) / 2][1], base], [next, self.key_points[next][0], base + offset], [next, self.key_points[next][1], base + offset], [next, self.key_points[next][0], base + side_length + offset], [next, self.key_points[next][1], base + side_length + offset], [(curr + next) / 2, self.key_points[(curr + next) / 2][0], base + side_length + 2 * offset], [(curr + next) / 2, self.key_points[(curr + next) / 2][1], base + side_length + 2 * offset], [curr, self.key_points[curr][0], base + side_length + offset], [curr, self.key_points[curr][1], base + side_length + offset]])\n        rectangle = [[x_coords[0], self.key_points[x_coords[0]][0], base + offset], [x_coords[0], self.key_points[x_coords[0]][1], base + offset], [x_coords[1], self.key_points[x_coords[1]][0], base + offset], [x_coords[1], self.key_points[x_coords[1]][1], base + offset], [x_coords[0], self.key_points[x_coords[0]][0], base + offset + side_length], [x_coords[0], self.key_points[x_coords[0]][1], base + offset + side_length], [x_coords[1], self.key_points[x_coords[1]][0], base + offset + side_length], [x_coords[1], self.key_points[x_coords[1]][1], base + offset + side_length]]\n        return (hexagons, rectangle)",
    "32": "def __init__(self, path, unit_dist):\n    img = cv2.imread(path)\n    green = [0, 255, 0]\n    y, x = np.where(np.all(img == green, axis=2))\n    points = []\n    for p1, p2 in zip(x, y):\n        points.append([p1, p2])\n    self.point_list = sorted(points, key=lambda x: int(x[0]))\n    self.start = self.point_list[0][0]\n    self.end = self.point_list[-1][0]\n    self.unit_dist = unit_dist\n    self.key_points = {}\n    self.x_coords = []",
    "33": "def set_key_points(self, inner_start=0):\n    num_rect = floor((self.end - self.start) / self.unit_dist) - 1\n    self.key_points[self.start] = []\n    x_coords = [self.start]\n    if not inner_start:\n        for i in range(0, num_rect + 1):\n            x_coords.append(x_coords[-1] + self.unit_dist)\n            self.key_points[x_coords[-1]] = []\n    else:\n        self.key_points[inner_start] = []\n        x_coords.append(inner_start)\n        for i in range(0, num_rect):\n            x_coords.append(x_coords[-1] + self.unit_dist)\n            self.key_points[x_coords[-1]] = []\n    for i in range(1, len(x_coords) - 1):\n        self.key_points[(x_coords[i] + x_coords[i + 1]) / 2] = []\n    for p in self.point_list:\n        if p[0] in self.key_points:\n            self.key_points[p[0]].append(p[1])\n    for p in self.key_points:\n        self.key_points[p] = [self.key_points[p][0], self.key_points[p][-1]]\n    self.x_coords = x_coords\n    return x_coords",
    "34": "def get_polygons(self, base):\n    x_coords = self.x_coords\n    hexagons = []\n    side_length, offset = self.get_measurements()\n    for i in range(1, len(x_coords) - 1):\n        curr = x_coords[i]\n        next = x_coords[i + 1]\n        hexagons.append([[curr, self.key_points[curr][0], base + offset], [curr, self.key_points[curr][1], base + offset], [(curr + next) / 2, self.key_points[(curr + next) / 2][0], base], [(curr + next) / 2, self.key_points[(curr + next) / 2][1], base], [next, self.key_points[next][0], base + offset], [next, self.key_points[next][1], base + offset], [next, self.key_points[next][0], base + side_length + offset], [next, self.key_points[next][1], base + side_length + offset], [(curr + next) / 2, self.key_points[(curr + next) / 2][0], base + side_length + 2 * offset], [(curr + next) / 2, self.key_points[(curr + next) / 2][1], base + side_length + 2 * offset], [curr, self.key_points[curr][0], base + side_length + offset], [curr, self.key_points[curr][1], base + side_length + offset]])\n    rectangle = [[x_coords[0], self.key_points[x_coords[0]][0], base + offset], [x_coords[0], self.key_points[x_coords[0]][1], base + offset], [x_coords[1], self.key_points[x_coords[1]][0], base + offset], [x_coords[1], self.key_points[x_coords[1]][1], base + offset], [x_coords[0], self.key_points[x_coords[0]][0], base + offset + side_length], [x_coords[0], self.key_points[x_coords[0]][1], base + offset + side_length], [x_coords[1], self.key_points[x_coords[1]][0], base + offset + side_length], [x_coords[1], self.key_points[x_coords[1]][1], base + offset + side_length]]\n    return (hexagons, rectangle)",
    "35": "def central_contour(contours, img_center):\n    index = 0\n    curr_min = 10000000\n    for i in range(len(contours)):\n        M = cv2.moments(contours[i])\n        if M['m00'] != 0:\n            x = int(M['m10'] / M['m00'])\n            y = int(M['m01'] / M['m00'])\n            center = (x, y)\n            distance = lambda p1, p2: math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n            dist = distance(center, img_center)\n            if dist < curr_min:\n                index = i\n                curr_min = dist\n    return contours[index]",
    "36": "def process_images(dir):\n    files = os.listdir(dir)\n    for file in files:\n        file_path = os.path.join(dir, file)\n        img = cv2.imread(file_path, 0)\n        filtered = cv2.bilateralFilter(img, 9, 75, 75)\n        hist = cv2.equalizeHist(filtered)\n        smooth = cv2.fastNlMeansDenoising(hist, 70, 70, 7, 21)\n        kernel = np.ones((5, 5), np.uint8)\n        img_dilation = cv2.dilate(smooth, kernel, iterations=1)\n        cv2.imwrite(file_path, img_dilation)\n    return",
    "37": "def threshold(view, img_range, lower_value, upper_value):\n    start = img_range[0]\n    end = img_range[1]\n    count = 0\n    files = os.listdir(view + '/PreProImages')\n    for file_name in files:\n        if start > count or end < count:\n            count += 1\n            continue\n        file_path = view + '/PreProImages/' + file_name\n        img_gray = cv2.imread(file_path, 0)\n        red_image = np.zeros((img_gray.shape[0], img_gray.shape[1], 3), np.uint8)\n        red_image[:] = (0, 0, 255)\n        lower_gray = np.array([lower_value])\n        upper_gray = np.array([upper_value])\n        lesion_mask = cv2.inRange(img_gray, lower_gray, upper_gray)\n        res = cv2.bitwise_and(red_image, red_image, mask=lesion_mask)\n        cv2.imwrite(view + '/Thresholded/' + file_name, res)\n        count += 1",
    "38": "def draw_contours(view, img_range, poi):\n    \"\"\"Function that draws contour lines on images based on given parameters\"\"\"\n    print('\\nStarting contour drawings!')\n    hull_list = []\n    files = os.listdir(view + '/Thresholded')\n    for file_name in files:\n        file_path = view + '/Thresholded/' + file_name\n        original_path = file_path.replace('Thresholded', 'PreProImages')\n        res = cv2.imread(file_path)\n        gray = cv2.cvtColor(res, cv2.COLOR_BGR2GRAY)\n        img_center = (poi[0], poi[1])\n        contours, hierarchy = cv2.findContours(gray, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n        center_contour = [central_contour(contours, img_center)]\n        cv2.drawContours(res, center_contour, -1, (0, 255, 0), 1)\n        img_original = cv2.imread(original_path)\n        img_original_convex = cv2.imread(original_path)\n        cv2.drawContours(img_original, contours, -1, (0, 255, 0), 1)\n        hull_res = cv2.imread(file_path)\n        rect_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 30))\n        threshed = cv2.morphologyEx(gray, cv2.MORPH_CLOSE, rect_kernel)\n        hull_contours, hierarchy = cv2.findContours(threshed, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)\n        hull_center_contour = cv2.convexHull(central_contour(hull_contours, img_center))\n        hull_list.append(hull_center_contour)\n        hull_center_contour = [hull_center_contour]\n        cv2.drawContours(hull_res, hull_center_contour, -1, (0, 255, 0), 1)\n        cv2.drawContours(img_original_convex, hull_center_contour, -1, (0, 255, 0), 1)\n        cv2.imwrite(view + '/Convex/hull' + file_name, hull_res)\n        cv2.imwrite(view + '/OverlayedConvexImages/' + file_name, img_original_convex)\n    print('\\nFinished contour drawings!\\n')\n    return hull_list",
    "39": "def retrace_callback(event, x, y, flags, param):\n    \"\"\"Callback function to help user draw lines on image.\"\"\"\n    img = param[0]\n    points = param[1]\n    if event == cv2.EVENT_LBUTTONDBLCLK:\n        cv2.circle(img, (x, y), 4, (255, 0, 0), -1)\n        points.append([[x, y]])\n        i = len(points) - 1\n        if i > 0:\n            cv2.line(img, tuple(points[i - 1][0]), tuple(points[i][0]), (0, 0, 255), 1)",
    "40": "def draw_points(img):\n    \"\"\"Creates OpenCV Window with selected image. Draws points in \"connect the dots\" fashion\"\"\"\n    points = []\n    param = [img, points]\n    cv2.namedWindow('image')\n    cv2.setMouseCallback('image', retrace_callback, param)\n    while 1:\n        cv2.imshow('image', img)\n        if cv2.waitKey(20) & 255 == 27:\n            break\n    cv2.destroyAllWindows()\n    return points",
    "41": "from math import floor\nimport cv2\nimport numpy as np\n\nclass RiemannHelper(object):\n    def __init__(self, img, unit_dist):\n        green = [0,255,0]\n        y, x = np.where(np.all(img==green,axis=2))\n        points = []\n        for (p1,p2) in zip(x,y): points.append([p1,p2])\n        self.point_list = sorted(points, key=lambda x: int(x[0]))\n        self.start = self.point_list[0][0]\n        self.end = self.point_list[-1][0]\n        self.unit_dist = unit_dist\n        self.key_points = {}\n\n    def get_key_points(self):\n        num_rect = floor((self.end - self.start)/self.unit_dist) - 1\n        self.key_points[self.start] = []\n        x_coords = [self.start]\n        for i in range(0, num_rect + 1):\n            x_coords.append(x_coords[-1] + self.unit_dist)\n            self.key_points[x_coords[-1]] = []\n\n        for p in self.point_list:\n            if p[0] in self.key_points:\n                self.key_points[p[0]].append(p[1])\n        \n        for p in self.key_points:\n            self.key_points[p] = [self.key_points[p][0], self.key_points[p][-1]]\n\n        return x_coords\n    \n    def get_polygons(self):\n        x_coords = self.get_key_points()\n        polygons = []\n        \n        for i in range(0, len(x_coords) - 1):   \n            curr = x_coords[i]\n            next = x_coords[i+1]\n            polygons.append([[curr, self.key_points[curr][0]],\n                            [next, self.key_points[next][0]],\n                            [next, self.key_points[next][1]],\n                            [curr, self.key_points[curr][1]]]\n                           )\n\n        return polygons\n\n    \n\n\n    ",
    "42": "class RiemannHelper(object):\n\n    def __init__(self, img, unit_dist):\n        green = [0, 255, 0]\n        y, x = np.where(np.all(img == green, axis=2))\n        points = []\n        for p1, p2 in zip(x, y):\n            points.append([p1, p2])\n        self.point_list = sorted(points, key=lambda x: int(x[0]))\n        self.start = self.point_list[0][0]\n        self.end = self.point_list[-1][0]\n        self.unit_dist = unit_dist\n        self.key_points = {}\n\n    def get_key_points(self):\n        num_rect = floor((self.end - self.start) / self.unit_dist) - 1\n        self.key_points[self.start] = []\n        x_coords = [self.start]\n        for i in range(0, num_rect + 1):\n            x_coords.append(x_coords[-1] + self.unit_dist)\n            self.key_points[x_coords[-1]] = []\n        for p in self.point_list:\n            if p[0] in self.key_points:\n                self.key_points[p[0]].append(p[1])\n        for p in self.key_points:\n            self.key_points[p] = [self.key_points[p][0], self.key_points[p][-1]]\n        return x_coords\n\n    def get_polygons(self):\n        x_coords = self.get_key_points()\n        polygons = []\n        for i in range(0, len(x_coords) - 1):\n            curr = x_coords[i]\n            next = x_coords[i + 1]\n            polygons.append([[curr, self.key_points[curr][0]], [next, self.key_points[next][0]], [next, self.key_points[next][1]], [curr, self.key_points[curr][1]]])\n        return polygons",
    "43": "def __init__(self, img, unit_dist):\n    green = [0, 255, 0]\n    y, x = np.where(np.all(img == green, axis=2))\n    points = []\n    for p1, p2 in zip(x, y):\n        points.append([p1, p2])\n    self.point_list = sorted(points, key=lambda x: int(x[0]))\n    self.start = self.point_list[0][0]\n    self.end = self.point_list[-1][0]\n    self.unit_dist = unit_dist\n    self.key_points = {}",
    "44": "def get_key_points(self):\n    num_rect = floor((self.end - self.start) / self.unit_dist) - 1\n    self.key_points[self.start] = []\n    x_coords = [self.start]\n    for i in range(0, num_rect + 1):\n        x_coords.append(x_coords[-1] + self.unit_dist)\n        self.key_points[x_coords[-1]] = []\n    for p in self.point_list:\n        if p[0] in self.key_points:\n            self.key_points[p[0]].append(p[1])\n    for p in self.key_points:\n        self.key_points[p] = [self.key_points[p][0], self.key_points[p][-1]]\n    return x_coords",
    "45": "def get_polygons(self):\n    x_coords = self.get_key_points()\n    polygons = []\n    for i in range(0, len(x_coords) - 1):\n        curr = x_coords[i]\n        next = x_coords[i + 1]\n        polygons.append([[curr, self.key_points[curr][0]], [next, self.key_points[next][0]], [next, self.key_points[next][1]], [curr, self.key_points[curr][1]]])\n    return polygons",
    "46": "from ctypes.wintypes import PSIZE\nimport cv2\nimport numpy as np\nfrom deprecated.old_riemann_helper import RiemannHelper\nimport os\nfrom mayavi.mlab import *\n\nview = input('Enter view:')\ndir = view + '/Convex'\nprint(dir)\nfiles = os.listdir(dir)\nx = []\ny = []\nz = []\ntriangles = []\ndepth = 0\ncount = 0\nfor file in files:\n    path = dir + '/' + file\n    img = cv2.imread(path)\n    rh = RiemannHelper(img, 10)\n    polygons = rh.get_polygons()\n    for p in polygons:\n        count += 1\n        for l in p:\n            x.append(l[0])\n            y.append(l[1])\n            z.append(depth)\n            x.append(l[0])\n            y.append(l[1])\n            z.append(depth + 7.5)\n        p = np.array(p)\n        cv2.polylines(img,[p],1,(255,0,0),1)        \n    depth += 7.5\n\n\nfor i in range(0, count):\n    triangles.append((np.array([0,4,6]) + (i * 8)))\n    triangles.append((np.array([0,2,4]) + (i * 8)))\n    triangles.append((np.array([0,1,6]) + (i * 8)))\n    triangles.append((np.array([1,6,7]) + (i * 8)))\n    triangles.append((np.array([1,3,5]) + (i * 8)))\n    triangles.append((np.array([1,5,7]) + (i * 8)))\n    triangles.append((np.array([2,3,4]) + (i * 8)))\n    triangles.append((np.array([3,4,5]) + (i * 8)))\n\n# triangular_mesh(x,y,z,triangles, color = (1,1,1))\ntriangular_mesh(x,y,z,triangles)\nsavefig('triangles.obj')\nshow()\n"
}